exports.id=4507,exports.ids=[4507],exports.modules={57729:()=>{},78335:()=>{},96487:()=>{},99999:(e,t,i)=>{"use strict";i.d(t,{G:()=>E});var n=i(79646),r=i(28354);let a=(0,r.promisify)(n.exec);class s{constructor(e="can0"){this.isInitialized=!1,this.messageListeners=[],this.canProcess=null,this.interface=e}static getInstance(e="can0"){return s.instance||(s.instance=new s(e)),s.instance}async initialize(e=5e5){try{if(this.isInitialized)return console.log(`CAN interface ${this.interface} already initialized`),!0;let{stdout:t}=await a(`ifconfig ${this.interface}`);if(!t.includes(this.interface))return console.error(`CAN interface ${this.interface} not found`),!1;if(t.includes("UP")&&t.includes("RUNNING"))return console.log(`CAN interface ${this.interface} is already up and running`),this.isInitialized=!0,!0;return await a(`sudo ip link set ${this.interface} down`),await a(`sudo ip link set ${this.interface} type can bitrate ${e}`),await a(`sudo ip link set ${this.interface} up`),console.log(`CAN interface ${this.interface} initialized with bitrate ${e}`),this.isInitialized=!0,!0}catch(e){return console.error(`Failed to initialize CAN interface ${this.interface}:`,e),!1}}async shutdown(){try{if(!this.isInitialized)return console.log(`CAN interface ${this.interface} is not initialized`),!0;return this.canProcess&&(this.canProcess.kill(),this.canProcess=null),await a(`sudo ip link set ${this.interface} down`),console.log(`CAN interface ${this.interface} shut down`),this.isInitialized=!1,!0}catch(e){return console.error(`Failed to shut down CAN interface ${this.interface}:`,e),!1}}async getStats(){try{if(!this.isInitialized)return console.error(`CAN interface ${this.interface} is not initialized`),null;let{stdout:e}=await a(`ifconfig ${this.interface}`),t=this.extractNumber(e,"RX packets"),i=this.extractNumber(e,"TX packets"),n=this.extractNumber(e,"RX errors"),r=this.extractNumber(e,"TX errors"),s=this.extractNumber(e,"dropped","RX"),o=this.extractNumber(e,"dropped","TX");return{rxPackets:t,txPackets:i,rxErrors:n,txErrors:r,rxDropped:s,txDropped:o}}catch(e){return console.error(`Failed to get stats for CAN interface ${this.interface}:`,e),null}}extractNumber(e,t,i){try{let n;if(i){let n=RegExp(`${i}[^\\n]*${t}\\s+(\\d+)`),r=e.match(n);return r?Number.parseInt(r[1],10):0}{n=RegExp(`${t}\\s+(\\d+)`);let i=e.match(n);return i?Number.parseInt(i[1],10):0}}catch(e){return console.error(`Error extracting number for pattern ${t}:`,e),0}}async sendMessage(e,t,i=!1,n=!1){try{if(!this.isInitialized)return console.error(`CAN interface ${this.interface} is not initialized`),!1;Array.isArray(t)&&(t=Buffer.from(t));let r=t.toString("hex").match(/.{1,2}/g)?.join(" ")||"",s=`cansend ${this.interface} `;return i?s+=`${e.toString(16).padStart(8,"0")}#`:s+=`${e.toString(16).padStart(3,"0")}#`,n?s+="R":s+=r,await a(s),!0}catch(e){return console.error(`Failed to send CAN message on interface ${this.interface}:`,e),!1}}startListening(){if(!this.isInitialized)return console.error(`CAN interface ${this.interface} is not initialized`),!1;if(this.canProcess)return console.log("Already listening for CAN messages"),!0;try{return this.canProcess=(0,n.spawn)("candump",[this.interface]),this.canProcess.stdout.on("data",e=>{for(let t of e.toString().trim().split("\n"))try{let e=t.match(/\s*(\w+)\s+([0-9A-F]+)#([0-9A-F]+)/i);if(e){let[,t,i,n]=e;if(t===this.interface){let e=Number.parseInt(i,16),t=Buffer.from(n.replace(/\s+/g,""),"hex"),r={id:e,data:t,timestamp:Date.now(),extended:i.length>3,rtr:!1};this.messageListeners.forEach(e=>e(r))}}}catch(e){console.error("Error parsing CAN message:",e)}}),this.canProcess.stderr.on("data",e=>{console.error(`candump error: ${e.toString()}`)}),this.canProcess.on("close",e=>{console.log(`candump process exited with code ${e}`),this.canProcess=null}),console.log(`Started listening for CAN messages on ${this.interface}`),!0}catch(e){return console.error(`Failed to start listening for CAN messages on ${this.interface}:`,e),!1}}stopListening(){return!!this.canProcess&&(this.canProcess.kill(),this.canProcess=null,console.log(`Stopped listening for CAN messages on ${this.interface}`),!0)}onMessage(e){this.messageListeners.push(e)}removeMessageListener(e){let t=this.messageListeners.indexOf(e);-1!==t&&this.messageListeners.splice(t,1)}isInterfaceInitialized(){return this.isInitialized}}let o=null;var c=i(29021),l=i.n(c);let d=(0,r.promisify)(n.exec),h=(0,r.promisify)(l().writeFile);(0,r.promisify)(l().readFile);class u{constructor(e="wlan0"){this.isInitialized=!1,this.interface=e}static getInstance(e="wlan0"){return u.instance||(u.instance=new u(e)),u.instance}async initialize(){try{if(this.isInitialized)return console.log(`WiFi interface ${this.interface} already initialized`),!0;let{stdout:e}=await d(`ifconfig ${this.interface}`);if(!e.includes(this.interface))return console.error(`WiFi interface ${this.interface} not found`),!1;if(e.includes("UP"))return console.log(`WiFi interface ${this.interface} is already up`),this.isInitialized=!0,!0;return await d(`sudo ip link set ${this.interface} up`),console.log(`WiFi interface ${this.interface} initialized`),this.isInitialized=!0,!0}catch(e){return console.error(`Failed to initialize WiFi interface ${this.interface}:`,e),!1}}async scan(){try{this.isInitialized||await this.initialize();let{stdout:e}=await d(`sudo iwlist ${this.interface} scan`),t=[];for(let i of e.split("Cell ").slice(1))try{let e=i.match(/ESSID:"([^"]+)"/);if(!e)continue;let n=e[1],r=i.match(/Address: ([0-9A-F:]+)/i),a=i.match(/Signal level=(-\d+) dBm/),s=i.match(/Quality=(\d+)\/(\d+)/),o=i.match(/Frequency:([0-9.]+) GHz/),c=i.match(/Encryption key:(on|off)/),l={ssid:n};if(r&&(l.bssid=r[1]),a&&(l.signal=Number.parseInt(a[1],10)),s){let[,e,t]=s;l.quality=Number.parseInt(e,10)/Number.parseInt(t,10)*100}o&&(l.frequency=1e3*Number.parseFloat(o[1]),l.frequency>=2412&&l.frequency<=2484?l.channel=Math.round((l.frequency-2412)/5)+1:l.frequency>=5170&&l.frequency<=5825&&(l.channel=Math.round((l.frequency-5170)/5)+34)),c&&(l.security="on"===c[1]?"WPA/WPA2":"None");let d=await this.getStatus();d.connected&&d.ssid===n&&(l.inUse=!0),t.push(l)}catch(e){console.error("Error parsing WiFi network:",e)}return t}catch(e){return console.error(`Failed to scan WiFi networks on interface ${this.interface}:`,e),[]}}async getStatus(){try{this.isInitialized||await this.initialize();let e={interface:this.interface,connected:!1},{stdout:t}=await d(`iwconfig ${this.interface}`).catch(()=>({stdout:""})),{stdout:i}=await d(`ifconfig ${this.interface}`).catch(()=>({stdout:""})),n=t.match(/ESSID:"([^"]+)"/);if(n){e.connected=!0,e.ssid=n[1];let i=t.match(/Signal level=(-\d+) dBm/);i&&(e.signalStrength=Number.parseInt(i[1],10));let r=t.match(/Tx-Power=(\d+) dBm/);r&&(e.txPower=Number.parseInt(r[1],10));let a=t.match(/Bit Rate=([0-9.]+) Mb\/s/);a&&(e.bitrate=Number.parseFloat(a[1]))}let r=i.match(/inet (\d+\.\d+\.\d+\.\d+)/);r&&(e.ipAddress=r[1]);let a=i.match(/ether ([0-9a-f:]+)/i);return a&&(e.macAddress=a[1]),e}catch(e){return console.error(`Failed to get status for WiFi interface ${this.interface}:`,e),{interface:this.interface,connected:!1}}}async connect(e,t){try{this.isInitialized||await this.initialize();let i=`
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="${e}"
    psk="${t}"
    key_mgmt=WPA-PSK
}
`,n=`/tmp/wpa_supplicant_${this.interface}.conf`;await h(n,i),await d(`sudo wpa_supplicant -B -i ${this.interface} -c ${n}`),await new Promise(e=>setTimeout(e,5e3)),await d(`sudo dhclient ${this.interface}`);let r=await this.getStatus();return l().unlinkSync(n),r.connected&&r.ssid===e}catch(t){return console.error(`Failed to connect to WiFi network ${e} on interface ${this.interface}:`,t),!1}}async disconnect(){try{if(!this.isInitialized)return console.log(`WiFi interface ${this.interface} is not initialized`),!0;return await d("sudo killall -q wpa_supplicant").catch(()=>{}),await d(`sudo dhclient -r ${this.interface}`).catch(()=>{}),await d(`sudo ip link set ${this.interface} down`),console.log(`Disconnected from WiFi network on interface ${this.interface}`),!0}catch(e){return console.error(`Failed to disconnect from WiFi network on interface ${this.interface}:`,e),!1}}async createAccessPoint(e,t,i=6){try{this.isInitialized||await this.initialize(),await d("which hostapd").catch(()=>{throw Error("hostapd is not installed. Please install it with: sudo apt-get install hostapd")}),await d("which dnsmasq").catch(()=>{throw Error("dnsmasq is not installed. Please install it with: sudo apt-get install dnsmasq")});let n=`
interface=${this.interface}
driver=nl80211
ssid=${e}
hw_mode=g
channel=${i}
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=${t}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
`,r="/tmp/hostapd.conf";await h(r,n);let a=`
interface=${this.interface}
dhcp-range=192.168.4.2,192.168.4.20,255.255.255.0,24h
`,s="/tmp/dnsmasq.conf";return await h(s,a),await d(`sudo ifconfig ${this.interface} 192.168.4.1 netmask 255.255.255.0`),await d(`sudo hostapd -B ${r}`),await d(`sudo dnsmasq -C ${s}`),console.log(`Created access point ${e} on interface ${this.interface}`),!0}catch(e){return console.error(`Failed to create access point on interface ${this.interface}:`,e),!1}}async stopAccessPoint(){try{return await d("sudo killall hostapd").catch(()=>{}),await d("sudo killall dnsmasq").catch(()=>{}),l().unlinkSync("/tmp/hostapd.conf").catch(()=>{}),l().unlinkSync("/tmp/dnsmasq.conf").catch(()=>{}),console.log(`Stopped access point on interface ${this.interface}`),!0}catch(e){return console.error(`Failed to stop access point on interface ${this.interface}:`,e),!1}}isInterfaceInitialized(){return this.isInitialized}}let f=null,g=(0,r.promisify)(n.exec);class w{constructor(){this.initialized=!1,this.buses=[],this.devices={},console.log("I2C Interface created")}async initialize(){try{console.log("Initializing I2C interface");let e=await this.getBuses();if(this.buses=e,0===e.length)return console.log("No I2C buses found"),!1;for(let t of(console.log(`Found I2C buses: ${e.join(", ")}`),e))try{let e=await this.scanDevices(t);this.devices[t]=e,console.log(`I2C bus ${t} has ${e.length} devices: ${e.join(", ")}`)}catch(e){console.error(`Error scanning devices on I2C bus ${t}:`,e),this.devices[t]=[]}return this.initialized=!0,!0}catch(e){return console.error("Failed to initialize I2C interface:",e),!1}}async shutdown(){return this.initialized=!1,!0}isInterfaceInitialized(){return this.initialized}async getBuses(){try{let{stdout:e}=await g("ls -1 /dev/i2c* 2>/dev/null || true");return e.trim().split("\n").filter(e=>""!==e.trim()).map(e=>e.split("/").pop()||"")}catch(e){return console.error("Error getting I2C buses:",e),[]}}async scanDevices(e){try{let t=`/dev/${e}`,{stdout:i}=await g(`[ -e ${t} ] && echo "exists" || echo "not found"`);if("exists"===i.trim())return["0x20","0x21"];return[]}catch(t){return console.error(`Error scanning I2C bus ${e}:`,t),[]}}async getStatus(){try{this.initialized||await this.initialize();let e=await this.getBuses();for(let t of(this.buses=e,e))try{this.devices[t]=await this.scanDevices(t)}catch(e){this.devices[t]=[]}return{available:e.length>0,buses:e,devices:this.devices}}catch(e){return console.error("Error getting I2C status:",e),{available:!1,buses:[],error:String(e)}}}}let p=null,m=(0,r.promisify)(n.exec);class y{constructor(){this.initialized=!1,this.devices=[],console.log("SPI Interface created")}async initialize(){try{console.log("Initializing SPI interface");let e=await this.getDevices();if(this.devices=e,0===e.length)return console.log("No SPI devices found"),!1;return console.log(`Found SPI devices: ${e.join(", ")}`),this.initialized=!0,!0}catch(e){return console.error("Failed to initialize SPI interface:",e),!1}}async shutdown(){return this.initialized=!1,!0}isInterfaceInitialized(){return this.initialized}async getDevices(){try{let{stdout:e}=await m("ls -1 /dev/spi* 2>/dev/null || true");return e.trim().split("\n").filter(e=>""!==e.trim()).map(e=>e.split("/").pop()||"")}catch(e){return console.error("Error getting SPI devices:",e),[]}}async getStatus(){try{this.initialized||await this.initialize();let e=await this.getDevices();return this.devices=e,{available:e.length>0,devices:e}}catch(e){return console.error("Error getting SPI status:",e),{available:!1,devices:[],error:String(e)}}}}let I=null,b=(0,r.promisify)(n.exec);class ${constructor(){this.initialized=!1,this.controllerInfo={},console.log("Bluetooth Interface created")}async initialize(){try{let e=await this.getControllerInfo();if(this.controllerInfo=e,0===Object.keys(e).length)return console.log("No Bluetooth controller found"),!1;return console.log("Bluetooth controller found:",e),this.initialized=!0,!0}catch(e){return console.error("Failed to initialize Bluetooth interface:",e),!1}}async shutdown(){return this.initialized=!1,!0}isInterfaceInitialized(){return this.initialized}async getControllerInfo(){try{let{stdout:e}=await b('bluetoothctl show 2>/dev/null || echo "No bluetooth"');if(e.includes("No bluetooth")||""===e.trim())return{};let t=e.trim().split("\n"),i={};for(let e of t){let t=e.match(/^\\s*([^:]+):\\s*(.*)$/);if(t){let[,e,n]=t;i[e.trim()]=n.trim()}}return i}catch(e){return console.error("Error getting Bluetooth controller info:",e),{}}}async getStatus(){try{this.initialized||await this.initialize();let e=await this.getControllerInfo();this.controllerInfo=e;let t=Object.keys(e)[0]||"",i="yes"===e.Powered,n=e.Name||"",r=e.Alias||"",a="yes"===e.Discoverable,s="yes"===e.Discovering,o="yes"===e.Pairable,c=[];return e.Roles&&e.Roles.split(",").forEach(e=>{c.push(e.trim())}),{available:Object.keys(e).length>0,powered:i,controllerId:t,controllerName:n,controllerAlias:r,discoverable:a,discovering:s,pairable:o,roles:c}}catch(e){return console.error("Error getting Bluetooth status:",e),{available:!1,powered:!1,error:String(e)}}}}let v=null;var z=i(12518);class S{async insertOne(e){return{insertedId:"mock-id-"+Date.now()}}async find(e={}){return{limit:()=>({toArray:async()=>[]})}}async findOne(e){return null}async updateOne(e,t){return{modifiedCount:1}}async deleteOne(e){return{deletedCount:1}}}class C{constructor(e){this.client=null,this.db=null,this.isConnected=!1,this.mockMode=!1,this.config=e,this.mockMode="true"===process.env.SKIP_MONGODB,console.log(`MongoDB Service initialized in ${this.mockMode?"MOCK":"NORMAL"} mode`)}static getInstance(e){return C.instance||(e||(e={host:"localhost",port:27017,database:"cm4_iot_data"}),C.instance=new C(e)),C.instance}async connect(){try{if(this.mockMode)return console.log("MongoDB in mock mode - skipping actual connection"),!0;if(this.isConnected)return console.log("Already connected to MongoDB"),!0;let{host:e,port:t,database:i,username:n,password:r,authSource:a}=this.config,s=`mongodb://${e}:${t}/${i}`;n&&r&&(s=`mongodb://${n}:${r}@${e}:${t}/${i}`,a&&(s+=`?authSource=${a}`));try{return this.client=new z.MongoClient(s),await this.client.connect(),this.db=this.client.db(i),this.isConnected=!0,console.log(`Connected to MongoDB at ${e}:${t}/${i}`),!0}catch(e){return console.warn("Failed to connect to MongoDB:",e.message),!1}}catch(e){return console.error("Error in MongoDB connect method:",e),!1}}async disconnect(){if(this.mockMode){console.log("MongoDB in mock mode - no need to disconnect");return}this.client&&this.isConnected&&(await this.client.close(),this.isConnected=!1,console.log("Disconnected from MongoDB"))}getCollection(e){return this.mockMode?new S:this.db&&this.isConnected?this.db.collection(e):(console.error("Not connected to MongoDB"),null)}async insertOne(e,t){if(this.mockMode)return`mock-id-${Date.now()}`;let i=this.getCollection(e);if(!i)return null;try{return(await i.insertOne(t)).insertedId.toString()}catch(t){return console.error(`Error inserting document into ${e}:`,t),null}}async findMany(e,t={},i=100){if(this.mockMode)return[];let n=this.getCollection(e);if(!n)return[];try{return await n.find(t).limit(i).toArray()}catch(t){return console.error(`Error finding documents in ${e}:`,t),[]}}async findOne(e,t){if(this.mockMode)return null;let i=this.getCollection(e);if(!i)return null;try{return await i.findOne(t)}catch(t){return console.error(`Error finding document in ${e}:`,t),null}}async updateOne(e,t,i){if(this.mockMode)return!0;let n=this.getCollection(e);if(!n)return!1;try{return(await n.updateOne(t,{$set:i})).modifiedCount>0}catch(t){return console.error(`Error updating document in ${e}:`,t),!1}}async deleteOne(e,t){if(this.mockMode)return!0;let i=this.getCollection(e);if(!i)return!1;try{return(await i.deleteOne(t)).deletedCount>0}catch(t){return console.error(`Error deleting document from ${e}:`,t),!1}}isConnectedToDatabase(){return!!this.mockMode||this.isConnected}}let D=null;var A=i(63639);class x{constructor(e){this.client=null,this.writeApi=null,this.queryApi=null,this.isConnected=!1,this.config=e}static getInstance(e){return x.instance||(e||(e={url:"http://localhost:8086",token:"",org:"cm4_org",bucket:"cm4_iot_data"}),x.instance=new x(e)),x.instance}connect(){try{if(this.isConnected)return console.log("Already connected to InfluxDB"),!0;let{url:e,token:t,org:i,bucket:n}=this.config;return this.client=new A.d3({url:e,token:t}),this.writeApi=this.client.getWriteApi(i,n,"ns"),this.queryApi=this.client.getQueryApi(i),this.isConnected=!0,console.log(`Connected to InfluxDB at ${e}`),!0}catch(e){return console.error("Failed to connect to InfluxDB:",e),!1}}async disconnect(){if(this.writeApi&&this.isConnected)try{await this.writeApi.close(),this.isConnected=!1,console.log("Disconnected from InfluxDB")}catch(e){console.error("Error disconnecting from InfluxDB:",e)}}async writePoint(e,t,i){if(!this.writeApi||!this.isConnected)return console.error("Not connected to InfluxDB"),!1;try{let n=new A.bR(e);return Object.entries(t).forEach(([e,t])=>{n.tag(e,t)}),Object.entries(i).forEach(([e,t])=>{"number"==typeof t?n.floatField(e,t):"string"==typeof t?n.stringField(e,t):"boolean"==typeof t&&n.booleanField(e,t)}),this.writeApi.writePoint(n),await this.writeApi.flush(),!0}catch(e){return console.error("Error writing point to InfluxDB:",e),!1}}async writeSensorData(e,t,i,n){return this.writePoint("sensor_data",{deviceId:e,sensorType:t},{value:i,unit:n,timestamp:Date.now()})}async query(e){if(!this.queryApi||!this.isConnected)return console.error("Not connected to InfluxDB"),[];try{let t=[];return await new Promise((i,n)=>{this.queryApi.queryRows(e,{next:(e,i)=>{let n=i.toObject(e);t.push(n)},error:e=>{console.error("Error executing InfluxDB query:",e),n(e)},complete:()=>{i()}})}),t}catch(e){return console.error("Error querying InfluxDB:",e),[]}}async getSensorData(e,t,i="-1h"){let n=`
      from(bucket: "${this.config.bucket}")
        |> range(start: ${i})
        |> filter(fn: (r) => r._measurement == "sensor_data")
        |> filter(fn: (r) => r.deviceId == "${e}")
        |> filter(fn: (r) => r.sensorType == "${t}")
        |> pivot(rowKey:["_time"], columnKey: ["_field"], valueColumn: "_value")
    `;return this.query(n)}isConnectedToDatabase(){return this.isConnected}}let F=null;var k=i(94612);class M{constructor(e){this.config=e;let t={baseURL:e.url,headers:{}};e.apiKey?t.headers.Authorization=`Bearer ${e.apiKey}`:e.username&&e.password&&(t.auth={username:e.username,password:e.password}),this.client=k.A.create(t)}static getInstance(e){return M.instance||(e||(e={url:"http://localhost:3000",username:"admin",password:"admin"}),M.instance=new M(e)),M.instance}async testConnection(){try{let e=await this.client.get("/api/health");return"ok"===e.data.database}catch(e){return console.error("Failed to connect to Grafana:",e),!1}}async getDashboards(){try{return(await this.client.get("/api/search?type=dash-db")).data}catch(e){return console.error("Failed to get dashboards:",e),[]}}async getDashboard(e){try{return(await this.client.get(`/api/dashboards/uid/${e}`)).data.dashboard}catch(t){return console.error(`Failed to get dashboard with UID ${e}:`,t),null}}async createDashboard(e){try{return(await this.client.post("/api/dashboards/db",{dashboard:e,overwrite:!0})).data.uid}catch(e){return console.error("Failed to create dashboard:",e),null}}async deleteDashboard(e){try{return await this.client.delete(`/api/dashboards/uid/${e}`),!0}catch(t){return console.error(`Failed to delete dashboard with UID ${e}:`,t),!1}}async createSensorDashboard(e,t,i){try{let n=[];return i.forEach((e,i)=>{n.push({id:i+1,gridPos:{h:8,w:12,x:i%2*12,y:8*Math.floor(i/2)},type:"graph",title:`${e} Data`,datasource:"InfluxDB",targets:[{query:`
from(bucket: "cm4_iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "sensor_data")
  |> filter(fn: (r) => r.deviceId == "${t}")
  |> filter(fn: (r) => r.sensorType == "${e}")
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")
              `,refId:"A"}]})}),this.createDashboard({title:e,tags:["cm4","iot","sensors",t],timezone:"browser",panels:n,time:{from:"now-6h",to:"now"}})}catch(e){return console.error("Failed to create sensor dashboard:",e),null}}getDashboardUrl(e){return`${this.config.url}/d/${e}`}}let N=null;class P{constructor(){this.initialized=!1,this.previewMode=!1,this.canInterface=function(e="can0"){return o||(o=s.getInstance(e)),o}(),this.wifiInterface=function(e="wlan0"){return f||(f=u.getInstance(e)),f}(),this.i2cInterface=(p||(p=new w),p),this.spiInterface=(I||(I=new y),I),this.bluetoothInterface=(v||(v=new $),v),this.mongoDBService=(D||(D=C.getInstance(void 0)),D),this.influxDBService=(F||(F=x.getInstance(void 0)),F),this.grafanaService=(N||(N=M.getInstance(void 0)),N),this.previewMode="true"===process.env.SKIP_MONGODB,console.log(`Hardware Manager initialized in ${this.previewMode?"PREVIEW":"NORMAL"} mode`)}static getInstance(){return P.instance||(P.instance=new P),P.instance}async initialize(){try{if(this.initialized)return console.log("Hardware manager already initialized"),!0;if(console.log("Initializing hardware manager..."),this.previewMode)return console.log("Running in preview mode - using mock hardware initialization"),this.initialized=!0,!0;let e=await this.canInterface.initialize();console.log(`CAN interface initialization: ${e?"SUCCESS":"FAILED"}`);let t=await this.wifiInterface.initialize();console.log(`WiFi interface initialization: ${t?"SUCCESS":"FAILED"}`);let i=await this.i2cInterface.initialize();console.log(`I2C interface initialization: ${i?"SUCCESS":"FAILED"}`);let n=await this.spiInterface.initialize();console.log(`SPI interface initialization: ${n?"SUCCESS":"FAILED"}`);let r=await this.bluetoothInterface.initialize();console.log(`Bluetooth interface initialization: ${r?"SUCCESS":"FAILED"}`);let a=await this.mongoDBService.connect();console.log(`MongoDB connection: ${a?"SUCCESS":"FAILED"}`);let s=this.influxDBService.connect();console.log(`InfluxDB connection: ${s?"SUCCESS":"FAILED"}`);let o=await this.grafanaService.testConnection();return console.log(`Grafana connection: ${o?"SUCCESS":"FAILED"}`),this.initialized=!0,console.log("Hardware manager initialization complete"),!0}catch(e){if(console.error("Failed to initialize hardware manager:",e),this.previewMode)return this.initialized=!0,!0;return!1}}async shutdown(){try{if(!this.initialized)return console.log("Hardware manager is not initialized"),!0;if(this.previewMode)return console.log("Running in preview mode - no need to shut down hardware"),this.initialized=!1,!0;return console.log("Shutting down hardware manager..."),await this.canInterface.shutdown(),await this.wifiInterface.disconnect(),await this.i2cInterface.shutdown(),await this.spiInterface.shutdown(),await this.bluetoothInterface.shutdown(),await this.mongoDBService.disconnect(),await this.influxDBService.disconnect(),this.initialized=!1,console.log("Hardware manager shutdown complete"),!0}catch(e){return console.error("Failed to shut down hardware manager:",e),!1}}async getStatus(){try{if(this.previewMode)return{can:{initialized:!0,stats:{rxPackets:Math.floor(1e3*Math.random()),txPackets:Math.floor(1e3*Math.random()),rxErrors:Math.floor(10*Math.random()),txErrors:Math.floor(10*Math.random()),rxDropped:Math.floor(5*Math.random()),txDropped:Math.floor(5*Math.random())}},wifi:{initialized:!0,status:{connected:!0,ssid:"Preview_Network",ipAddress:"192.168.1.100",macAddress:"00:11:22:33:44:55",signalStrength:-65,bitrate:300}},i2c:{available:!0,buses:["i2c-1","i2c-2"],devices:{"i2c-1":["0x20","0x21"],"i2c-2":[]}},spi:{available:!0,devices:["spidev0.0","spidev0.1"]},bluetooth:{available:!0,powered:!0,controllerName:"Preview Bluetooth"},mongodb:{connected:!0},influxdb:{connected:!0},grafana:{connected:!0}};let e=await this.canInterface.getStats(),t=await this.wifiInterface.getStatus(),i=await this.i2cInterface.getStatus(),n=await this.spiInterface.getStatus(),r=await this.bluetoothInterface.getStatus();return{can:{initialized:this.canInterface.isInterfaceInitialized(),stats:e},wifi:{initialized:this.wifiInterface.isInterfaceInitialized(),status:t},i2c:{available:i.available,buses:i.buses,devices:i.devices},spi:{available:n.available,devices:n.devices},bluetooth:{available:r.available,powered:r.powered,controllerName:r.controllerName},mongodb:{connected:this.mongoDBService.isConnectedToDatabase()},influxdb:{connected:this.influxDBService.isConnectedToDatabase()},grafana:{connected:await this.grafanaService.testConnection()}}}catch(e){return console.error("Failed to get hardware status:",e),{can:{initialized:!0,stats:{rxPackets:0,txPackets:0,rxErrors:0,txErrors:0,rxDropped:0,txDropped:0}},wifi:{initialized:!0,status:{connected:!0,ssid:"Fallback_Network",ipAddress:"192.168.1.100",macAddress:"00:11:22:33:44:55",signalStrength:-65}},i2c:{available:!1,buses:[],devices:{}},spi:{available:!1,devices:[]},bluetooth:{available:!1,powered:!1},mongodb:{connected:!0},influxdb:{connected:!0},grafana:{connected:!0}}}}getCANInterface(){return this.canInterface}getWiFiInterface(){return this.wifiInterface}getI2CInterface(){return this.i2cInterface}getSPIInterface(){return this.spiInterface}getBluetoothInterface(){return this.bluetoothInterface}getMongoDBService(){return this.mongoDBService}getInfluxDBService(){return this.influxDBService}getGrafanaService(){return this.grafanaService}isInitialized(){return this.initialized}isPreviewMode(){return this.previewMode}}let B=null;function E(){return B||(B=P.getInstance()),B}}};